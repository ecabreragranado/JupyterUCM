{"type":"cell","id":"020fd8","pos":24,"input":"#### Ejercicio 1","cell_type":"markdown"}
{"type":"cell","id":"12379b","pos":32,"input":"La Función de Transferencia de Modulación (MTF por sus siglas en inglés) nos da información de cómo varía el contraste en la imagen. Más concretamente, si tenemos un objeto cosenoidal caracterizado por una cierta frecuencia (o periodo), con contraste igual a 1, entonces, el contraste de la imagen (que también será cosenoidal), será el valor de la MTF para la frecuencia del objeto.\n\nSi tenemos en cuenta que cualquier objeto puede ser descompuesto en una suma de cosenos de distinta frecuencia y dirección, entonces vemos que la MTF contiene la información de cómo varía el contraste de la imagen de cualquier objeto en función de la frecuencia espacial. \n\n**Se denomina frecuencia de corte del sistema óptico a aquella frecuencia para la cual el contraste en la imagen es 0, es decir, para la cual el valor de la MTF es nulo**. Esta frecuencia de corte puede depender de la dirección.\n\nEs necesario señalar que la MTF sólo nos aporta información del contraste. Para obtener una información completa de la imagen, nos falta otro elemento: la fase. Es decir, cómo varían las posiciones de los máximos y mínimos de cada uno de los cosenos en los que se descompone el objeto, sin por ello variar su frecuencia. Esta información la contiene la denominada Función de Transferencia de Fase (PTF). A su vez, tanto la MTF como la PTF están contenidas en la Función de Transferencia Óptica (OTF), ya que, \n\n$$OTF = MTF e^{i PTF}$$\n\nEs decir, la MTF es el módulo de la OTF mientras que la PTF es su fase.\nUn sistema óptico puede caracterizarse tanto por la PSF como por la OTF, estando relacionadas entre sí por medio de una Transformada de Fourier.\n\nA continuación definiremos la función que calcula la MTF sabiendo la PSF del sistema, así como la función de representación de la MTF, funciones que utilizaremos en las cuestiones planteadas.","cell_type":"markdown"}
{"type":"cell","id":"135d1d","pos":43,"input":"#Indica aquí las operaciones para hallar la frecuencia espacial del objeto cosenoidal en ciclos/grado\n","cell_type":"code"}
{"type":"cell","id":"1e91c2","pos":14,"input":"### PSF","cell_type":"markdown"}
{"type":"cell","id":"1f41e0","pos":12,"input":"--------\nPara incluir la aberración de onda en el cálculo de la imagen dada por un sistema óptico, es necesario definir una función pupila generalizada que las incluya. Esto se realiza utilizando la expresión:\n\n$$P_{gen} = P(x,y) e^{i k W(x,y)}$$\n\nsiendo $k = \\frac{2 \\pi}{\\lambda_m}$ con $\\lambda_m$ la longitud de onda en el medio, $P(x,y)$ la función pupila y por último $W(x,y)$ la función aberración que se expresa como suma de polinomios de Zernike. Esta pupila generalizada ha de redefinirse con la aberración correspondiente si cambiamos los coeficientes de Zernike.\n\n\n\n","cell_type":"markdown"}
{"type":"cell","id":"20d045","pos":17,"input":"### Imagen Final","cell_type":"markdown"}
{"type":"cell","id":"25c672","pos":10,"input":"## Tarea 1. Pupila Generalizada, PSF y cálculo de la imagen final","cell_type":"markdown"}
{"type":"cell","id":"2aa8c1","pos":39,"input":"La MTF nos da la información de cómo varía el contraste de la imagen dada por el sistema cuando varíamos la frecuencia espacial del objeto. Para ver esta propiedad, vamos a cargar en el documento un objeto con únicamente una frecuencia espacial, es decir, un objeto en donde la intensidad varía cosenoidalmente. A continuación calcularemos la imagen que el sistema proporciona de dicho objeto y calcularemos el contraste por inspección directa. Finalmente, compararemos el valor dado por la MTF con el contraste medido directamente de la imagen.\n\nEl siguiente código muestra el objeto y la imagen que proporciona el sistema óptico junto a dos perfiles espaciales que nos ayudan a calcular el contraste. ","cell_type":"markdown"}
{"type":"cell","id":"362dee","pos":9,"input":"La definición de los coeficientes del desarrollo en polinomios de Zernike de la aberración de onda la dejamos para los casos que vamos a estudiar.\n\n----","cell_type":"markdown"}
{"type":"cell","id":"3cc99a","pos":35,"input":"# SOLO EJECUTAR\ncoefs = loadtxt('ejemplo_Zernike_psf.dat')\npsf = calcula_PSF(coefs,pupila) # solo necesaria si se desea visualizar la PSF del sistema\ndibuja_PSF(psf,lambdam,zi,pupila_radio,npixels) # solo necesaria si se desea visualizar la PSF del sistema\nmtf = calcula_MTF(coefs,pupila)\ndibuja_MTF(mtf,lambdam,zi,pupila_radio,npixels)","cell_type":"code"}
{"type":"cell","id":"4e0149","pos":42,"input":"1. Para una distancia de 2 m, calcular la frecuencia espacial del objeto en ciclos/grado, así como su contraste (utilizar la inspección directa en las gráficas superiores para ver el contraste del objeto).\n\n2. Ejecutar la celda que se proporciona para obtener mediante inspección de la gráfica del perfil de la MTF su valor a la frecuencia del objeto.¿Con qué se relaciona este valor?.\n\n3. Repetir los dos puntos anteriores para una distancia igual a 3 m.\n\nNota: La distancia se fija en el código mostrado en la celda superior a través de la variable `dist`.","cell_type":"markdown"}
{"type":"cell","id":"5064b9","pos":26,"input":"## Tarea 2. Razón de Strehl","cell_type":"markdown"}
{"type":"cell","id":"51a589","pos":40,"input":"# SOLO EJECUTAR\nobjeto = imread('cos_frec_005lr.jpg',flatten=True)\n# A continuación, la variable que modifica la distancia a la\n# que se encuentra el objeto\n##########\ndist = 3.0\n#########\nimagen_cos=calc_imagen(coefs,objeto,dist)\n\nfigcut = figure(figsize=(14,3))\nncut = shape(objeto)[0]/2\nperfilobjeto = objeto[ncut,:]\n\nnum_pixeles_x = objeto.shape[0]\nnum_pixeles_y = objeto.shape[1]\npixel_tam_x = objeto_tam/num_pixeles_x\npixel_tam_y = objeto_tam/num_pixeles_y\nx_obj = arange(num_pixeles_x)*pixel_tam_x*1e3 # en mm\ny_obj = arange(num_pixeles_y)*pixel_tam_y*1e3 # en mm\n\nthetarad=objeto_tam/dist #angulo en radianes\n# angulo refractado \nthetatrans=thetarad/indice\n# tamagno en vertical (en metros) de la imagen paraxial\nimagen_tam=zi*tan(thetatrans)\npixel_tam_imag = imagen_tam/num_pixeles_y\ny_im = arange(num_pixeles_y)*pixel_tam_imag*1e3 # en mm\n\nncut = shape(imagen_cos)[0]/2\nperfilimagen = imagen_cos[ncut,:]\nsubplot(121)\nplot(y_obj,perfilobjeto)\nxlim(0,y_obj[-1])\nxlabel('mm')\nylabel('perfil objeto')\n\nsubplot(122)\nplot(y_im,perfilimagen)\nxlim(0,y_im[-1])\nxlabel('mm')\nylabel('perfil imagen')\n\n\nplugins.connect(figcut, plugins.MousePosition(fontsize=14))","cell_type":"code"}
{"type":"cell","id":"51d3a8","pos":19,"input":"# SOLO EJECUTAR\nfrom scipy.ndimage import imread\nfrom scipy.interpolate import interp2d\nfrom scipy.signal import convolve2d\n\ndef calc_imagen(C,objeto,distancia):\n    num_pixeles_x = objeto.shape[0]\n    num_pixeles_y = objeto.shape[1]\n    pixel_tam_x = objeto_tam/num_pixeles_x\n    #pixel_tam_y = objeto_tam/num_pixeles_y\n    x_obj = arange(num_pixeles_x)*pixel_tam_x*1e3 # en mm\n    y_obj = arange(num_pixeles_y)*pixel_tam_x*1e3 # en mm\n\n    # Definimos el angulo subtendido por el objeto en la direccion vertical\n    # y calculamos el tamagno en el plano imagen de la imagen paraxial.\n    thetarad=objeto_tam/distancia #angulo en radianes\n    # angulo refractado \n    thetatrans=thetarad/indice\n    # tamagno en vertical (en metros) de la imagen paraxial\n    imagenparax_tam=zi*tan(thetatrans)\n    pixel_tam_imagparax = imagenparax_tam/num_pixeles_y\n    ximagparax = arange(num_pixeles_x)*pixel_tam_imagparax*1e3 # en mm\n    yimagparax = arange(num_pixeles_y)*pixel_tam_imagparax*1e3 # en mm\n    # Pinta la imagen paraxial\n    #ax = fig.add_subplot(121, aspect='equal')\n    figim = figure(figsize=(14,6))\n    subplot(1,2,1)\n    imshow(objeto,extent=(x_obj[0],x_obj[-1],y_obj[0],y_obj[-1]),cmap='gray')\n    xlabel('mm')\n    ylabel('mm')\n    xlim(0,objeto_tam*1e3)\n    ylim(0,objeto_tam*1e3)\n    #title('Imagen paraxial',fontsize=16)\n    title('Objeto',fontsize=16)\n\n\n    #################################################################\n    # 2. INTERPOLA LA PSF PARA QUE COINCIDA CON EL OBJETO\n    #################################################################\n    #Define las frecuencias espaciales\n    fx=linspace(-0.5,0.5,npixels) # frecuencias adimensionales (en 1/pixels) desde -0.5 a 0.5 \n    fx=fx/(dx*pupila_radio) # frecuencias con dimensiones (en 1/m)\n    fy=fx\n    # Nuevas coordenadas espaciales\n    xnew=fx*lambdam*zi\n    ynew=xnew\n    dxnew=xnew[2]-xnew[1] # tamaño del pixel\n    npixelsi=(max(xnew)-min(xnew))/pixel_tam_imagparax\n    \n    xnewi=arange(min(xnew),max(xnew),pixel_tam_imagparax)    \n    ynewi=xnewi\n    [Xnewi,Ynewi]=meshgrid(xnewi,ynewi) # coordenadas definidas en la matriz\n    funPSFint = interp2d(xnew,ynew,calcula_PSF(C,pupila))\n    psfi = funPSFint(xnewi,ynewi)\n    psfi=psfi/(sum(psfi)) # Normalizamos la PSF para que la energia total sea 1\n\n    #################################################################\n    # CALCULA SU IMAGEN CON LA PSF \n    #################################################################\n\n    imagen=convolve2d(objeto,psfi,'same')\n    #ax1 = fig.add_subplot(122, aspect='equal')\n    subplot(1,2,2)\n    imshow(imagen,extent=(ximagparax[0],ximagparax[-1],yimagparax[0],yimagparax[-1]),cmap='gray')\n    #yaxis.tick_right()\n    xlabel('mm')\n    ylabel('mm')\n\n    xlim(0,ximagparax[-1])\n    ylim(0,yimagparax[-1])\n    title('Imagen con aberraciones',fontsize=16)\n    return imagen","cell_type":"code"}
{"type":"cell","id":"615b56","pos":3,"input":"%pylab inline\nimport mpld3\nfrom mpld3 import plugins\nmpld3.enable_notebook()","output":{"0":{"name":"stdout","output_type":"stream","text":"Populating the interactive namespace from numpy and matplotlib\n"},"1":{"ename":"ImportError","evalue":"No module named 'mpld3'","output_type":"error","traceback":["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m","\u001b[1;31mImportError\u001b[0m                               Traceback (most recent call last)","\u001b[1;32m<ipython-input-1-fa5dc4352998>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[0mget_ipython\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mmagic\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'pylab inline'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[1;32mimport\u001b[0m \u001b[0mmpld3\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      3\u001b[0m \u001b[1;32mfrom\u001b[0m \u001b[0mmpld3\u001b[0m \u001b[1;32mimport\u001b[0m \u001b[0mplugins\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      4\u001b[0m \u001b[0mmpld3\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0menable_notebook\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n","\u001b[1;31mImportError\u001b[0m: No module named 'mpld3'"]}},"cell_type":"code","exec_count":1}
{"type":"cell","id":"69e48f","pos":4,"input":"A continuación definimos los parámetros físicos del sistema con el que vamos a trabajar en esta parte de la práctica:","cell_type":"markdown"}
{"type":"cell","id":"6d0c31","pos":13,"input":"# SOLO EJECUTAR\n# Pupila generalizada\ndef pupila_gen(Coeficientes,pupila):\n     return pupila*exp(1.0j*(2*pi/lambdam)*W(Coeficientes,zernike,pupila))","cell_type":"code"}
{"type":"cell","id":"6e2a04","pos":20,"input":"Si queremos calcular la PSF del sistema y visualizarla, seguiríamos los siguientes pasos:\n\n1. Definición de la aberración de onda por medio de los coeficientes de los polinomios de Zernike\n\n2. Cálculo de la PSF por medio de la función `psf`  (En esta función, se incluye la llamada a `pupila_gen` que nos devuelve la pupila generalizada, incluyendo aberraciones)\n\n3. Si se quiere dibujar, utilizaríamos la función `dibuja_PSF`.\n\nPor ejemplo, podríamos visualizar la PSF del sistema óptico caracterizado por unos coeficientes del desarrollo en polinomios de Zernike de la aberración de onda almacenados en el archivo `ejemplo_Zernike_psf.dat`","cell_type":"markdown"}
{"type":"cell","id":"70fd62","pos":1,"input":"## Pasos previos","cell_type":"markdown"}
{"type":"cell","id":"71124b","pos":30,"input":"## Tarea 3. MTF y Contraste de la imagen","cell_type":"markdown"}
{"type":"cell","id":"774349","pos":6,"input":"### Pupila del sistema, polinomios de Zernike y Aberración de Onda","cell_type":"markdown"}
{"type":"cell","id":"7aeb42","pos":5,"input":"pupila_diametro=5.4e-3 # Diametro de la pupila del sistema en m\nindice=4.0/3 # índice del medio\nzi=22.55e-3 # distancia de la pupila al plano imagen en m\nlambda0=500.0e-9 # longitud de onda en el vacio en m\n\npupila_radio=pupila_diametro/2 # radio de la pupila\nlambdam=lambda0/indice # longitud de onda en el medio","cell_type":"code"}
{"type":"cell","id":"7b6eaf","pos":22,"input":"----\n\nSi queremos calcular la imagen definiendo una nueva aberración de onda seguiríamos los siguientes pasos:\n\n1. Definición de la aberración de onda por medio de los coeficientes de los polinomios de Zernike\n\n2. Cálculo de la imagen final por medio de la función `calc_imagen` (Nota: hay que definir un objeto, su tamaño y una distancia a la que se observaría dicho objeto).\n\nPor ejemplo, utilizando los coeficientes anteriormente cargados,podemos calcular la imagen de la letra E que cargamos del archivo `E1.jpg`, de la siguiente forma.","cell_type":"markdown"}
{"type":"cell","id":"80b01c","pos":38,"input":"### MTF y contraste","cell_type":"markdown"}
{"type":"cell","id":"862468","pos":27,"input":"La razón de Strehl proporciona una métrica de la calidad de la imagen basada en la comparación\nentre la imagen obtenida por el sistema real y la que se obtendría teóricamente en ausencia de\naberraciones. Se define por el cociente entre el máximo de la PSF del sistema con aberraciones y el\nmáximo de la PSF del mismo sistema pero en ausencia de aberraciones. Es decir,\n\n$$Strehl = \\frac{max(PSF_{real})}{max(PSF_{ideal})}$$\n\nEn el caso en que las aberraciones del sistema no degraden mucho la imagen, se puede demostrar que ambas magnitudes están relacionadas por la expresion,\n\n$$Strehl= \\exp [−( 2 \\pi RMS / \\lambda )^2 ]$$\n\nEn este apartado vamos a calcular la razón de Strehl atendiendo a su definición, es decir, como el cociente entre los máximos de las PSF correspodientes al sistema con aberraciones y sin ellas (sistema ideal únicamente limitado por la difracción, en donde tendremos la mancha de Airy como PSF). Posteriormente, comprobaremos si la expresión aproximada anterior es válida en el caso planteado.","cell_type":"markdown"}
{"type":"cell","id":"88965d","pos":25,"input":"1. Dibujar la PSF y la imagen predicha para la letra E que se encuentra en el fichero `E1.jpg` para una aberración de onda caracterizada por un valor de S = 0.1 D (esfera), suponiendo un valor nulo para los coeficientes del desarrollo de Zernike no relacionados con S. Utilizar para visualizar la imagen de la letra E una distancia de 1.5 m y un tamaño del objeto de 2 cm.\n\n2. Repetir el apartado anterior para S = 0.3 D. ¿Qué ha provocado en la PSF un aumento de S?\n\n3.  Dibujar la PSF y la imagen predicha para la letra E que se encuentra en el fichero `E1.jpg` para una aberración de onda caracterizada por un valor de C = 0.1 D (cilindro), y por un valor de $\\theta$ = 24$^o$ (eje),  suponiendo un valor nulo para los coeficientes del desarrollo de Zernike no relacionados con C ni con $\\theta$.\n\n4. Repetir el apartado anterior para C = 0.3 D y $\\theta$ = 24$^o$ (eje). Comentar los cambios en la PSF al aumentar el valor de C.\n\n5. Repetir el apartado 4 para C = 0.1 D y $\\theta$ = 80$^o$ (eje).Comentar los cambios en la PSF al cambiar el valor de $\\theta$ con respecto al estudiado en el apartado 3.","cell_type":"markdown"}
{"type":"cell","id":"90badb","pos":36,"input":"#### Ejercicio 3","cell_type":"markdown"}
{"type":"cell","id":"91fef7","pos":21,"input":"# SOLO EJECUTAR\ncoefs = loadtxt('ejemplo_Zernike_psf.dat')\nprint coefs\npsf = calcula_PSF(coefs,pupila)\ndibuja_PSF(psf,lambdam,zi,pupila_radio,npixels)","cell_type":"code"}
{"type":"cell","id":"941307","pos":41,"input":"#### Ejercicio 4","cell_type":"markdown"}
{"type":"cell","id":"9a6090","pos":8,"input":"# SOLO EJECUTAR\n\n###########\n#Pupila\n##########\nnpixels=601 # Numero de pixels (usar un numero impar)\n# Magnitudes adimensionalizadas con el radio de la pupila\nx=linspace(-5,5,npixels) # coordenadas \ndx=x[2]-x[1] # tamaño del pixel (adimensionalziado por el radio de la pupila) \ny=x\nX,Y=meshgrid(x,y); # coordenadas definidas en la matriz\n# Funcion pupila (matriz de valores para cada para de coordenadas)\npupila=(X**2+Y**2<1.0)\n\n###########\n# Polinomios de Zernike hasta j = 14\n###########\nRHO=sqrt(X**2+Y**2)\nTHETA=arctan2(Y,X)\n\nzernike = zeros((15,X.shape[0],X.shape[1]))\n\nzernike[0] = ones(X.shape) # n = 0, m= 0. Término constante\nzernike[1] = 2.0*RHO*sin(THETA) # n = 1, m = -1. Tilt Y\nzernike[2] = 2.0*RHO*cos(THETA)# n = 1, m = 1. Tilt X\n#------\nzernike[3] = sqrt(6)*(RHO**2)*sin(2*THETA) #Astigmatismo primario Y\nzernike[4] = sqrt(3)*(2*RHO**2-1) #Desenfoque\nzernike[5] = sqrt(6)*(RHO**2)*cos(2*THETA) #Astigmatismo primario X\n#------\nzernike[6] = sqrt(8)*(RHO**3)*sin(3*THETA) #Trefoil Y\nzernike[7] = sqrt(8)*(3*RHO**3-2*RHO)*sin(THETA) #Coma Y\nzernike[8] = sqrt(8)*(3*RHO**3-2*RHO)*cos(THETA) #Coma X\nzernike[9] = sqrt(8)*(RHO**3)*cos(3*THETA) #Trefoil X\n#------\nzernike[10] = sqrt(10)*(RHO**4)*sin(4*THETA) #Cuadrafoil Y\nzernike[11] = sqrt(10)*(4*RHO**4-3*RHO**2)*sin(2*THETA) #Astigmatismo secundario Y\nzernike[12] = sqrt(5)*(6*RHO**4-6*RHO**2+1) #Esférica\nzernike[13] =sqrt(10)*(4*RHO**4-3*RHO**2)*cos(2*THETA)#Astigmatismo secundario X\nzernike[14] = sqrt(10)*(RHO**4)*cos(4*THETA) #Cuadrafoil X\n\n###########\n# Aberración de onda\n###########\n\ndef W(Coeficientes,zernike,pupila):\n    # Devuelve la aberracion de onda (Nota: coordenadas normalizadas al radio de la pupila)\n    return pupila*sum([Coeficientes[i]*zernike[i,:,:] for i in range(len(Coeficientes))],axis=0)","cell_type":"code"}
{"type":"cell","id":"9bc0f2","pos":16,"input":"# SOLO EJECUTAR\n#################################################################\n# PSF\n#################################################################\n\n# Calcula la FT, la centra y su modulo al cuadrado es la PSF\ndef calcula_PSF(C,pupila):\n    '''\n    calcula_PSF(C,pupila)\n    función para calcular la PSF del \n    sistema óptico. Llama a la función\n    pupila_gen(C,pupila) para calcular la pupila generalizada\n    C = coeficientes del desarrollo en polinomios de Zernike (en m)\n    pupila = matriz que nos da la pupila del sistema\n    '''\n    tfpupila=fftshift(fft2(pupila_gen(C,pupila)))\n    psf_sin_norm = (abs(tfpupila))**2 # Modulo al cuadrado por iluminación incoherente\n    return psf_sin_norm/sum(sum(psf_sin_norm)) # PSF normalizada para que la energía total sea 1\n\n#Representación\ndef dibuja_PSF(psf,lambdam,zi,pupila_radio,npixels):\n    '''\n    dibuja_PSF(psf,lambdam,zi,pupila_radio,npixels)\n    función para dibujar la psf previamente\n    calculada con la función calcula_PSF\n    psf = psf calculada con calcula_PSF\n    lambdam = longitud de onda en el medio en m\n    zi = distancia de la pupila al plano imagen en m\n    pupila_radio = radio de la pupila en m\n    npixels = número de pixels utilizado en la definición de la pupila\n    '''\n    #############\n    # Define las frecuencias espaciales\n    fx=linspace(-0.5,0.5,npixels) # frecuencias adimensionales (en 1/pixels) desde -0.5 a 0.5 \n    fx=fx/(dx*pupila_radio) # frecuencias con dimensiones (en 1/m)\n    fy=fx\n    # Nuevas coordenadas espaciales\n    xnew=fx*lambdam*zi\n    ynew=xnew\n    dxnew=xnew[2]-xnew[1] # tamaño del pixel\n    [Xnew,Ynew]=meshgrid(xnew,ynew); # coordenadas definidas en la matriz\n    # Pinta la PSF \n    fig = figure(figsize=(14,6))\n    subplot(1,2,1)\n    imshow(psf,extent=(xnew[0]*1e6,xnew[-1]*1e6,ynew[0]*1e6,ynew[-1]*1e6),cmap='afmhot')\n    xlabel('micras')\n    ylabel('micras')\n    title('PSF')\n    colorbar()\n\n    # Pinta perfil de la PSF\n    pixelcentro=(npixels+1)/2; # pixel central\n    psfy=psf[:,pixelcentro] # perfil PSF en y\n    psfx=psf[pixelcentro,:] # perfil PSF en x\n\n    subplot(1,2,2)\n    plot(ynew*1e6,psfy,'k',xnew*1e6,psfx,'r')\n    xlabel('micras')\n    ylabel('PSF perfil')\n    legend(('en y','en x'))\n    return 'ok'","cell_type":"code"}
{"type":"cell","id":"9f9ade","pos":23,"input":"# SOLO EJECUTAR\nobjeto = imread('E1.jpg',flatten=True)\nobjeto_tam = 0.02 # 2 cm de lado lateral de toda la imagen (la letra E ocupa menos)\ndistancia = 1.0 # en m\nimagen=calc_imagen(coefs,objeto,distancia)","cell_type":"code"}
{"type":"cell","id":"a1ccef","pos":29,"input":"1. Definir un array de 14 coeficientes correspondientes al sistema ideal. A continuación calcular y dibujar la PSF de este sistema ideal. \n\n2. Calcular y dibujar PSF del sistema óptico con las aberraciones definidas por el conjunto de coeficientes almacenados en el archivo `Zernike_paciente.dat`.\n\n3. Calcular la Razón de Strehl de este sistema según su definición y según la fórmula aproximada (utilizando el valor de la RMS calculado en el Trabajo Previo). Comentar el resultado\n\nNOTA: Para calcular el máximo de una array 2D (como es la PSF), utilizar `nombre_variable.max()`","cell_type":"markdown"}
{"type":"cell","id":"a377a1","pos":15,"input":"Ahora calculamos la Función de Dispersión de Punto (PSF), la cual proporciona la imagen de un objeto puntual dada por el sistema óptico. Esta función viene determinada por la pupila del sistema, mediante la expresión, \n\n$$PSF(x,y) \\propto |FT[P(x,y)]|^2$$\n\ndonde $FT$ significa transformada de Fourier y $P(x,y)$ es la función pupila de nuestro sistema óptico.\n\nSi el objeto en lugar de ser puntual, tiene una extensión espacial, la imagen la obtendremos superponiendo la contribución de todas las imágenes de cada uno de los puntos del objeto. Al considerar iluminación incoherente, esta superposición se realiza sobre las irradiancias resultantes de la imagen de cada punto del plano de observación. O dicho de otro modo, la imagen se obtiene mediante la convolución de la función PSF con el objeto.\n\n$$I(u,v) = \\int \\int O(x,y) PSF(u-x, v-y)dxdy$$\n\nSi el sistema presenta aberraciones, en la ecuación de definición de la PSF, tendremos que sustituir la función pupila $P(x,y)$ por la función pupila generalizada $P_{gen} = P(x,y) e^{i k W(x,y)}$ vista anteriormente.","cell_type":"markdown"}
{"type":"cell","id":"a74e40","pos":28,"input":"#### Ejercicio 2","cell_type":"markdown"}
{"type":"cell","id":"b24bed","pos":33,"input":"# SOLO EJECUTAR\n#################################################################\n# MTF\n#################################################################\n\n# Calcula la FT, la centra, y su modulo es la MTF\ndef calcula_MTF(C,pupila):\n    OTF=fftshift(fft2(calcula_PSF(C,pupila)))\n    MTF=abs(OTF)\n    return MTF/MTF.max() # Normalizamos la MTF para que el maximo valga 1\n\n\n# Pinta la MTF\ndef dibuja_MTF(mtf,lambdam,zi,pupila_radio,npixels):\n    # Define las frecuencias espaciales\n    fxadim=linspace(-0.5,0.5,npixels) # frecuencias adimensionales (en 1/pixels) desde -0.5 a 0.5 \n    fx=fxadim/(dx*pupila_radio) # frecuencias con dimensiones (en 1/m)\n    fy=fx\n    # Nuevas coordenadas espaciales\n    xnew=fx*lambdam*zi\n    ynew=xnew\n    dxnew=xnew[2]-xnew[1] # tamaño del pixel\n    [Xnew,Ynew]=meshgrid(xnew,ynew); # coordenadas definidas en la matriz\n    ffx=fxadim/dxnew # frecuencias con dimensiones (en 1/m)\n    ffy=ffx\n    figmtf=figure(figsize=(14,6))\n    subplot(1,2,1)\n    imshow(mtf,extent=(ffx[0]*1e-6,ffx[-1]*1e-6,ffy[0]*1e-6,ffy[-1]*1e-6),cmap='afmhot')\n    xlabel('cpm')\n    ylabel('cpm')\n    title('MTF')\n    colorbar()\n\n    # Pinta perfil de la MTF\n    pixelcentro=(npixels+1)/2; # pixel central\n    mtfy=mtf[:,pixelcentro] # perfil MTF en y\n    mtfx=mtf[pixelcentro,:] # perfil MTF en x\n\n    subplot(1,2,2)\n    plot(ffy*1e-6,mtfy,'k',ffx*1e-6,mtfx,'r')\n    xlabel('ciclos/micra')\n    ylabel('MTF perfil')\n    legend(('en y','en x'))\n    return 'ok'\n","cell_type":"code"}
{"type":"cell","id":"b98979","pos":0,"input":"# Tareas Práctica 5. Teoría Difraccional de la Imagen","cell_type":"markdown"}
{"type":"cell","id":"bc00f6","pos":44,"input":"# SOLO EJECUTAR\n# Celda para dibujar el perfil de la MTF (Apartado 2 del Ejercicio 4)\nmtf = calcula_MTF(coefs,pupila)\ndibuja_MTF(mtf,lambdam,zi,pupila_radio,npixels)\n\n# Pinta perfil de la MTF\npixelcentro = (npixels+1)/2; # pixel central\nmtfy=mtf[:,pixelcentro] # perfil MTF en y\nmtfx=mtf[pixelcentro,:] # perfil MTF en x\n\nfxadim=linspace(-0.5,0.5,npixels) # frecuencias adimensionales (en 1/pixels) desde -0.5 a 0.5 \nfx=fxadim/(dx*pupila_radio) # frecuencias con dimensiones (en 1/m)\nfy=fx\n# Nuevas coordenadas espaciales\nxnew=fx*lambdam*zi\nynew=xnew\ndxnew=xnew[2]-xnew[1] # tamaño del pixel\n[Xnew,Ynew]=meshgrid(xnew,ynew); # coordenadas definidas en la matriz\nffx=fxadim/dxnew # frecuencias con dimensiones (en 1/m)\nffy=ffx\n\nfxcpg = ffx*zi*pi/(180*indice)\nfycpg = fxcpg\n\nfigmtfprof = figure(figsize=(14,3))\nplot(fycpg,mtfy,fxcpg,mtfx)\n#xlim(0,0.001)\nxlabel('ciclos/grado')\nylabel('MTF perfil')\nlegend(('en y','en x'));\nplugins.connect(figmtfprof, plugins.MousePosition(fontsize=14))\n","cell_type":"code"}
{"type":"cell","id":"be9418","pos":18,"input":"Dado un objeto, que nosotros leeremos de un archivo y cargaremos en una variable `objeto`, si sabemos la PSF del sistema podemos calcular la imagen que obtendremos con dicho sistema óptico. El siguiente código carga el archivo deseado en la variable `objeto`, dado el tamaño del objeto y la distancia de observación, calcula la imagen dada por la Óptica Geométrica. Finalmente, calcula la imagen incluyendo las aberraciones. Para ello debemos realizar la convolución de la PSF del sistema con la imagen paraxial que obtendríamos por la Óptica Geómetrica, la cual es simplemente el objeto multiplicado por un factor de escala (el aumento del sistema).","cell_type":"markdown"}
{"type":"cell","id":"cbc950","pos":31,"input":"### MTF","cell_type":"markdown"}
{"type":"cell","id":"e2616d","pos":2,"input":"--------------\nPrimero cargamos en el documento todas las funciones de cálculo y dibujo que vamos a utilizar para obtener los resultados","cell_type":"markdown"}
{"type":"cell","id":"e960aa","pos":34,"input":"Así, si queremos visualizar la MTF partiendo de unos coeficientes de la expansión en polinomios de Zernike dados, seguiríamos los siguientes pasos","cell_type":"markdown"}
{"type":"cell","id":"f1f44d","pos":7,"input":"Tanto la pupila, como la definición de los polinomios de Zernike y la aberración de onda los necesitaremos en este documento. Al haber sido tratados anteriormente en el Trabajo Previo, únicamente aquí se reproduce su definición para poder usarlos más adelante.","cell_type":"markdown"}
{"type":"cell","id":"f2b310","pos":37,"input":"1. Dibujar la MTF para una aberración de onda caracterizada por un valor de S = 0.1 D (esfera), suponiendo un valor nulo para los coeficientes del desarrollo de Zernike no relacionados con S.\n\n2. Repetir el apartado anterior para S = 0.3 D. ¿Qué ha provocado en la MTF un aumento de S?. ¿Cómo cambia la frecuencia de corte del sistema?\n\n3.  Dibujar la MTF para una aberración de onda caracterizada por un valor de C = 0.1 D (cilindro), y por un valor de $\\theta$ = 24$^o$ (eje),  suponiendo un valor nulo para los coeficientes del desarrollo de Zernike no relacionados con C ni con $\\theta$. ¿Cómo cambia la frecuencia de corte del sistema comparada con la obtenida en el apartado 1?","cell_type":"markdown"}
{"type":"cell","id":"fd73d5","pos":11,"input":"### Pupila Generalizada","cell_type":"markdown"}
{"type":"file","last_load":1528208611692}
{"type":"settings","kernel":"python3","backend_state":"running","metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.4.3"}},"kernel_state":"idle","kernel_usage":{"cpu":0,"memory":77230080}}