{"output":{"0":{"name":"stdout","text":"Populating the interactive namespace from numpy and matplotlib\n"}},"exec_count":1,"start":1530255956957,"input":"%pylab inline","state":"done","pos":2,"cell_type":"code","type":"cell","end":1530255956988,"id":"7c0d96","kernel":"python3"}
{"type":"cell","id":"030541","pos":78,"input":"La función `linregress` toma como argumentos dos arrays `x` e `y`, que toma como dos conjuntos de medidas que deben tener la misma longitud. Por otro lado, devuelve,\n\n* `slope`, es decir, la pendiente que hemos llamado $m$ anteriormente,\n* `intercept`, que es la ordenada en el origen $b$,\n* `r_value` que es el coeficiente de correlación para estimar la bondad de nuestro ajuste.\n* `p_value` el cual es un parámetro que nos da la probabilidad de que nuestro resultado se pudiera obtener con un modelo distinto. En este caso, que la pendiente sea nula. Si es menor que un 5% aproximadamente, es que nuestra hipótesis inicial es correcta. \n* `stderr` nos da una medida de cuánto se aleja nuestra curva de los puntos experimentales\n\nDe la salida de la función, nos interesará los 3 primeros valores, especialmente.\nVamos a aplicarlo a un ejemplo. Primero cargaremos los datos de un fichero que tiene dos columnas y asignaremos cada columna a una variable `x` e `y`. ","cell_type":"markdown"}
{"type":"cell","id":"036a2b","pos":50,"input":"plot(tiempo,posicion,color='red',linewidth=2,linestyle='dashed')","cell_type":"code","exec_count":0}
{"type":"cell","id":"0753f0","pos":56,"input":"# Dibujar varias líneas a la vez en una misma figura","cell_type":"markdown"}
{"type":"cell","id":"0824bc","pos":81,"input":"plot(x,y,'o')","cell_type":"code","exec_count":0}
{"type":"cell","id":"0b7c17","pos":16,"input":"Here we obtained an array of two elements (due to the existence of two columns)\n\n\n¿what about selecting only the first 20 rows?","cell_type":"markdown"}
{"type":"cell","id":"0c29a1","pos":44,"input":"# Adición de etiquetas en los ejes","cell_type":"markdown"}
{"type":"cell","id":"0d9740","pos":97,"input":"c1_ini = 20.0\nc2_ini = 20.0\nt1_ini = 100.0\nt2_ini = 500.0\nparams_ini = [c1_ini,t1_ini,c2_ini,t2_ini] # ordenados según los requiere la función modelo.","cell_type":"code","exec_count":0}
{"type":"cell","id":"0dfe61","pos":55,"input":"# Otro ejemplo\nplot(tiempo,posicion,color='red',linewidth=2,linestyle='dashed')\nxlim(40,60)\nylim(-5,5)","cell_type":"code","exec_count":0}
{"type":"cell","id":"0e64dc","pos":3,"input":"# Data file managing","cell_type":"markdown"}
{"type":"cell","id":"0eb9cb","pos":90,"input":"Aunque en ocasiones podemos ajustar nuestras medidas para obtener información de un ajuste lineal, en la mayoría de los casos nuestro modelo será algo distinto a una recta. ¿Podemos obtener los parámetros de un modelo con una dependencia arbitraria mediante un ajuste a nuestras medidas experimentales?. La respuesta es, por supuesto, sí, y como se ha comentado anteriormente, Python proporciona múltiples funciones para hacer este tipo de análisis. \n\nNosotros vamos a centrarnos en la función `curve_fit`, la cual es parte del submódulo `optimize` de Scipy. Vamos a importarla y ver su funcionamiento con el comando help.","cell_type":"markdown"}
{"type":"cell","id":"0f620b","pos":25,"input":"# Suma, resta, multiplicación, etc","cell_type":"markdown"}
{"type":"cell","id":"0fff24","pos":28,"input":"nuevoarray = 5*cos(columna1) ","cell_type":"code","exec_count":0}
{"type":"cell","id":"106a3a","pos":32,"input":"Cuando hemos terminado de procesar los datos, frecuentemente querremos salvar los resultados en un fichero. Esta operación se realiza en Python con la función `savetxt`. Su funcionamiento es el siguiente:\n\n`savetxt('nombredelfichero', variable)`\n\nEs decir, primero damos el nombre del fichero entre comillas simples (o dobles, da igual) y a continuación, como segundo argumento, el nombre de la variable que queremos salvar. Veamos un ejemplo,","cell_type":"markdown"}
{"type":"cell","id":"155448","pos":75,"input":"# Regresión lineal","cell_type":"markdown"}
{"type":"cell","id":"16331c","pos":96,"input":"Ahora vamos a dar una sugerencia inicial a nuestros parámetros para que a `curve_fit` le sea más sencillo ajustar los datos experimentales","cell_type":"markdown"}
{"type":"cell","id":"16999a","pos":40,"input":"y = loadtxt('prueba_carga_fichero.dat')\ntiempo = y[:,0] # primera columna\nposicion = y[:,1] #segunda columna","cell_type":"code","exec_count":0}
{"type":"cell","id":"1d215b","pos":84,"input":"Ahora vamos a dibujar superpuestos nuestro modelo y nuestros datos experimentales","cell_type":"markdown"}
{"type":"cell","id":"1d8648","pos":57,"input":"Para ello se añaden dentro de plot los distintos pares de vectores $x$ e $y$ a representar, o bien se escribe otra sentencia con plot en la misma celda. Por ejemplo, calculemos la posición al cuadrado y representémosla junto a la posición.","cell_type":"markdown"}
{"type":"cell","id":"1f26a2","pos":19,"input":"filas15col1 = y[0:15,0]\nprint filas15col1","cell_type":"code","exec_count":0}
{"type":"cell","id":"20f9b6","pos":76,"input":"Supongamos que tenemos un conjunto de pares de datos $(X,Y)$, que sabemos (o sospechamos) que siguen una relación lineal. Es decir, \n\n$$Y = m X + b$$\n\n¿Cómo podemos con Python obtener $m$ y $b$?. Vamos a usar la función `linregress` del submódulo de Scipy dedicado a estadística *Scipy.stats*. Así pues lo primero que debemos hacer es importar esta función. Supondremos que ya tenemos cargados el resto de módulos por haber ejecutado anteriormente el comando `%pylab inline`. Si no es así, incluir este comando en la celda siguiente y ejecutarla.","cell_type":"markdown"}
{"type":"cell","id":"235976","pos":8,"input":"----------\nDone! our data file is already uploaded into our code. Let us learn now how to select some of the data in a particular way (columns, rows), and how to perform some operations with them.\n\n**¿How many rows and columns does the variable `y` have?**\n\nWe can know it by using the function `shape`, ","cell_type":"markdown"}
{"type":"cell","id":"2b806b","pos":83,"input":"pendiente, ordenada_origen,r,p,stderr = linregress(x,y)\nprint 'pendiente = ', pendiente\nprint 'ordenada en el origen = ' , ordenada_origen\nprint 'coeficiente de correlación r = ', r","cell_type":"code","exec_count":0}
{"type":"cell","id":"2c20c1","pos":69,"input":"Cuando trabajamos con cámaras CCD necesitaremos cargar en el programa una imagen ya capturada para realizar un análisis de ella, por ejemplo para realizar filtros, ver el tamaño de las estructuras observadas, etc.\n\nPara cargar imágenes se utiliza una función distinta a la de carga de ficheros de datos. Esta función se llama `imread`. Con esta función cargaremos la imagen en una variable, que será un array bidimensional (una matriz). Posteriormente, para visualizar la imagen debemos utilizar la función `imshow`. Veamos cómo funcionan con un ejemplo,","cell_type":"markdown"}
{"type":"cell","id":"2dfb81","pos":47,"input":"# Cambio de las propiedades de la línea dibujada","cell_type":"markdown"}
{"type":"cell","id":"2f545b","pos":11,"input":"columna1 = y[:,0]\ncolumna2 = y[:,1]","cell_type":"code","exec_count":0}
{"type":"cell","id":"31e136","pos":26,"input":"La suma, resta, multiplicación, división, elevar a una potencia, o aplicar una función a un array, se realizan como si fueran números. Por defecto Python realiza la operación elemento a elemento.","cell_type":"markdown"}
{"type":"cell","id":"331f1f","pos":38,"input":"La presentación de los resultados es una tarea esencial en cualquier trabajo, ya sea de laboratorio o de otro tipo. En esta sección vamos a ver cómo podemos hacer figuras en Python. La sintaxis es completamente similar a la utilizada en otros programas como Octave/MATLAB por lo que el paso a estos programas será muy sencillo si se aprende cómo hacerlo en Python.\n\n-----------\n\nEn esta parte asumiremos que ya tenemos un array o varios que queremos dibujar en una figura.","cell_type":"markdown"}
{"type":"cell","id":"35356b","pos":18,"input":"¿and what if we want to select the first 15 rows of the first column?","cell_type":"markdown"}
{"type":"cell","id":"3864b5","pos":74,"input":"**Introducción previa**\n\nPara hacer un ajuste a unos datos vamos a usar el módulo Scipy. Hay múltiples posibilidades en Scipy a la hora de abordar el ajuste de un conjunto de datos a un cierto modelo, sea este lineal (una recta), polinómico o una función arbitraria. Nos centraremos en cómo hacer una regresión lineal básica con Scipy y en cómo hacer un ajuste a un modelo arbitrario. En ambos casos, lo que subyace en los algoritmos utilizados es minimizar la suma de las distancias de nuestra curva ajuste a nuestros datos en cada punto. Es decir, un ajuste por mínimos cuadrados.","cell_type":"markdown"}
{"type":"cell","id":"38c608","pos":87,"input":"# Ejercicio 4","cell_type":"markdown"}
{"type":"cell","id":"3b976b","pos":41,"input":"Ahora queremos visualizar `posicion` frente a `tiempo`. Utilizaremos la función `plot` del módulo Matplotlib, que hemos cargado anteriormente.","cell_type":"markdown"}
{"type":"cell","id":"3c85c1","pos":27,"input":"multiplicacion = columna1*columna2\n\ndivision = columna1/columna2\n\npotencia = columna1**2\n\nsuma_col = columna1 + columna2","cell_type":"code","exec_count":0}
{"type":"cell","id":"3caff6","pos":89,"input":"# Ajuste a un modelo arbitrario","cell_type":"markdown"}
{"type":"cell","id":"42511e","pos":42,"input":"plot(tiempo,posicion)","cell_type":"code","exec_count":0}
{"type":"cell","id":"42a6a3","pos":59,"input":"plot(tiempo,posicion,color='red',linewidth=2,linestyle='dashed')\nplot(tiempo,pos2,color='blue',linewidth=2)","cell_type":"code","exec_count":0}
{"type":"cell","id":"44f197","pos":33,"input":"savetxt('prueba_salvar_datos.dat',suma_col)","cell_type":"code","exec_count":0}
{"type":"cell","id":"49f5ce","pos":58,"input":"pos2 = posicion**2\nplot(tiempo,posicion,tiempo,pos2)","cell_type":"code","exec_count":0}
{"type":"cell","id":"4ec123","pos":102,"input":"Vamos a ver ahora el resultado de nuestro ajuste, dibujando en una gráfica los puntos experimentales y nuestro modelo.","cell_type":"markdown"}
{"type":"cell","id":"524d5f","pos":45,"input":"Podemos añadir etiquetas en los ejes mediante los comandos `xlabel` e `ylabel`.","cell_type":"markdown"}
{"type":"cell","id":"5531bc","pos":101,"input":"c1_opt = params_opt[0]\nt1_opt = params_opt[1]\nc2_opt = params_opt[2]\nt2_opt = params_opt[3]","cell_type":"code","exec_count":0}
{"type":"cell","id":"57453b","pos":105,"input":"print pcov # Mostramos la matriz pcov","cell_type":"code","exec_count":0}
{"type":"cell","id":"581eb4","pos":9,"input":"shape(y)","cell_type":"code","exec_count":0}
{"type":"cell","id":"59494c","pos":17,"input":"filas20 = y[0:20,:]\nprint filas20","cell_type":"code","exec_count":0}
{"type":"cell","id":"5aec04","pos":48,"input":"Hay varias opciones para cambiar las líneas mostradas. Algunas de ellas son:\n\n* Cambio de anchura: Se añade a plot(tiempo,posición) `linewidth = número` donde número por defecto es 1, así que para aumentar el grosor de la línea habrá que indicar un número mayor (por ejemplo, 2)\n\n* Cambio de color: Se añade `color = nombre del cólor en inglés` por ejemplo 'orange', 'red', 'green', etc.\n\n* Cambio de formato: Si queremos que en vez de una línea contínua sea una línea discontínua añadiremos `linestyle='dashed'`, etc.","cell_type":"markdown"}
{"type":"cell","id":"5b47d7","pos":36,"input":"* Carga el fichero problema `'problema_datos.dat'` y realiza las siguientes operaciones\n\n    - Calcula la media y la desviación estandar de los datos almacenados en la segunda columna\n    \n    - Suma los elementos de cada columna.\n    \n    - Salva en un fichero el resultado de elevar al cubo la segunda columna.","cell_type":"markdown"}
{"type":"cell","id":"5d1c62","pos":4,"input":"When we work in a lab, we will have to analyze the experimental data. This means, uploading data to operate on them to for example find a theoretical fitting and plot them afterwards.\n\nIn this section of this numerical lesson we will learn how to do this. Let us suppose that we have previously used some experimental setup with which we have collected some numerical data saved in a data file, usually organized in several columns. Here we will see how to upload this data in our python environment, and make some calculations with them. In the following section, we will also learn how to make plots to present these data.","cell_type":"markdown"}
{"type":"cell","id":"61408f","pos":70,"input":"particulas = imread('nanopart1.jpg')\nimshow(particulas)","cell_type":"code","exec_count":0}
{"type":"cell","id":"62db1f","pos":64,"input":"figure(figsize=(15,4))\nsubplot(1,2,1) # subplot(numero filas, numero columnas, figura en la que dibujaremos)\nplot(tiempo,posicion, color='red', linewidth=2)\n\nsubplot(1,2,2) # ahora cambiando el último argumento elegimos la segunda figura para dibujar\nplot(tiempo,posicion-std(posicion), color='black', linewidth=2) # podemos hacer operaciones dentro de plot","cell_type":"code","exec_count":0}
{"type":"cell","id":"64204e","pos":92,"input":"Esta función es un poco más compleja que `linregress`, pero es el precio que pagamos por tener una herramienta más flexible. Vamos a describir los distintos argumentos de la función y cómo se emplea.\n\n\n* Argumentos\n\n    * `f` la cual es la función modelo a la que queremos ajustar nuestras medidas. La función `curve_fit` asume que nuestros datos (`x_data`, `ydata`) siguen esta función, es decir, `ydata = f(x_data, *params) + eps`. Aquí `eps` es un cierto error que el programa intentará minimizar, mientras que `*params` son los parámetros de nuestra función (es decir, otros argumentos de la función que no son nuestras medidas experimentales). \n    \n    Por ejemplo, si nuestros datos siguen una función gaussiana, $f(x) = a e^{-b(x-x_0)^2}$, los parámetros que variaremos para encontrar aquella que se ajuste a nuestros datos serán $a$ y $b$.\n    \n    * `xdata`,`ydata` son nuestros datos, los que queremos ajustar.\n    \n    * `p0` son los parámetros iniciales a partir de los cuales `curve_fit` intenta ajustar la función. Este argumento se puede no dar, en cuyo caso `curve_fit` comienza con los parámetros igual a 1. En nuestro ejemplo de la función gaussiana, los parámetros son [$a$,$b$] (escritos como una lista). Si sabemos que, por ejemplo, el valor de $a$ se encuentra próximo a 0.6 y $b$ próximo a 5.8, daríamos como sugerencia al programa `p0 = [0.6,5.8]`. **Dar una sugerencia inicial correcta al programa de ajuste permite que el ajuste se realice más rápidamente. Incluso podría ser que sin ella la función `curve_fit` no sea capaz de encontrar los parámetros adecuados**.\n    \n    * `sigma` es un vector que nos da el error de cada una de las medidas de `ydata`. Si no se especifica, se considera que los errores son nulos.\n     \n* Salida de `curve_fit`\n    \n    * `popt` Como salida de la función `curve_fit` obtenemos primero una lista de los parámetros óptimos que se han encontrado. En nuestro caso, si nuestros parámetros son [$a$,$b$], obtendríamos los parámetros óptimos del ajuste [$a_{opt}$, $b_{opt}$].\n    \n    * `pcov` es la matriz de covarianza de los parámetros. La raíz cuadrada de su diagonal nos proporciona el error (desviación estándar) de cada uno de los parámetros.\n    \n    \nVeamos un ejemplo de su uso. Vamos a intentar ajustar la caída de la señal de fluorescencia medida en una muestra de tejido con un tumor maligno a un modelo con una doble exponencial (este modelo se verá en las clases de teoría).","cell_type":"markdown"}
{"type":"cell","id":"64e8db","pos":23,"input":"# Otras operaciones con arrays","cell_type":"markdown"}
{"type":"cell","id":"68d389","pos":46,"input":"plot(tiempo,posicion)\nxlabel('Tiempo (s)')\nylabel('Posicion (cm)')","cell_type":"code","exec_count":0}
{"type":"cell","id":"73bda5","pos":63,"input":"Si la figura no queda bien de tamaño, podemos modificarla con el comando, \n\n`figure(figsize=(tamañoX, tamañoY))`\n\nLos parámetros de tamaño dependen de la resolución de la pantalla, así que lo mejor es probar con algunos hasta ver la figura de un tamaño adecuado.","cell_type":"markdown"}
{"type":"cell","id":"798e8c","pos":62,"input":"subplot(1,2,1) # subplot(numero filas, numero columnas, figura en la que dibujaremos)\nplot(tiempo,posicion, color='red', linewidth=2)\n\nsubplot(1,2,2) # ahora cambiando el último argumento elegimos la segunda figura para dibujar\nplot(tiempo,posicion-std(posicion), color='black', linewidth=2) # podemos hacer operaciones dentro de plot","cell_type":"code","exec_count":0}
{"type":"cell","id":"7a72dc","pos":53,"input":"¿Qué ocurre si no queremos representar todo el rango que recorren los datos?. Por ejemplo, ¿cómo hacemos para representar únicamente la región de tiempos entre 40 s y 60 s en el ejemplo anterior?. \n\nPara ello debemos modificar el rango de representación de los ejes. Se hace de la siguiente forma,","cell_type":"markdown"}
{"type":"cell","id":"7ade1a","pos":72,"input":"* Carga el fichero 'problema_figuras.dat' . Este fichero tiene 3 columnas. La primera se corresponde al tiempo, la segunda a la intensidad de la señal de fluorescencia medida para una cierta muestra, y la tercera, la misma fluorescencia pero para otra muestra diferente. Asigna cada columna a una variable distinta\n\n* A continuación, dibuja la segunda columna frente a la primera, utilizando un rango de representación adecuado, de modo que únicamente se vea el decaimiento de la señal desde su máximo. Indica utilizando las etiquetas que el eje X se corresponde con el tiempo y el eje Y se corresponde con la intensidad. \n\n* En una figura nueva, dibuja en dos subfiguras cada una de las señales de fluorescencia con respecto al tiempo. Añade etiquetas, utiliza un color diferente para cada una de las dos curvas y asigna un grosor de línea de 2 a ambas líneas.","cell_type":"markdown"}
{"type":"cell","id":"7cacea","pos":12,"input":"Notice that in Octave/MATLAB parentheses instead of square brackets are used and first column will be indexed by number 1 instead of 0.---------\n\nLet's select some of the rows now.","cell_type":"markdown"}
{"type":"cell","id":"7f826a","pos":68,"input":"# Trabajo con imágenes","cell_type":"markdown"}
{"type":"cell","id":"7f91d9","pos":49,"input":"plot(tiempo,posicion,color='orange')","cell_type":"code","exec_count":0}
{"type":"cell","id":"85ff59","pos":43,"input":"Vemos que ha salido una función sinusoidal. \n\nAhora vamos a describir algunas formas de modificar o enriquecer esta figura.","cell_type":"markdown"}
{"type":"cell","id":"86df87","pos":73,"input":"# Ajuste de datos","cell_type":"markdown"}
{"type":"cell","id":"881695","pos":61,"input":"Para hacer varias subfiguras podemos utilizar el comando `subplot` varias veces de la siguiente forma.","cell_type":"markdown"}
{"type":"cell","id":"88ea9e","pos":88,"input":"Carga los datos (2 columnas) del fichero `ejerc_reglin.dat` en una variable, y realiza un ajuste lineal a dichos datos. Muestra el valor de la pendiente y de la ordenada en el origen y justifica si consideras que el ajuste da la tendencia de los datos.","cell_type":"markdown"}
{"type":"cell","id":"896d87","pos":79,"input":"prueba = loadtxt('prueba_reglin.dat')\nx = prueba[:,0]\ny = prueba[:,1]","cell_type":"code","exec_count":0}
{"type":"cell","id":"8be5cd","pos":54,"input":"plot(tiempo,posicion,color='red',linewidth=2,linestyle='dashed')\nxlim(40,60)","cell_type":"code","exec_count":0}
{"type":"cell","id":"933318","pos":35,"input":"# Ejercicio 2","cell_type":"markdown"}
{"type":"cell","id":"98ed66","pos":39,"input":"--------\n\nSupongamos entonces que tenemos dos arrays, `tiempo` y `posicion` por ejemplo, que pueden provenir de cargar un fichero de datos, quizás del fichero utilizado anteriormente `prueba_carga_fichero.dat`.","cell_type":"markdown"}
{"type":"cell","id":"9a5c6a","pos":91,"input":"from scipy.optimize import curve_fit\nhelp(curve_fit)","cell_type":"code","exec_count":0}
{"type":"cell","id":"9b5c38","pos":82,"input":"Ahora realizamos el ajuste siguiendo la ayuda de la función `linregress` que nos indica cómo introducir los datos","cell_type":"markdown"}
{"type":"cell","id":"9b649b","pos":6,"input":"y = loadtxt('data_file.dat')","cell_type":"code","exec_count":0}
{"type":"cell","id":"9bb22c","pos":86,"input":"Uno de los problemas que podemos tener al usar la función `linregress` es obtener el error en la pendiente y la ordenada en el origen. Estos errores no son devueltos por esta función, por lo que deberíamos calcularlos a mano. Sin embargo, también podemos usar otras funciones más completas en Python para obtenerlos. Una de ellas es la función `curve_fit` la cual veremos a continuación.","cell_type":"markdown"}
{"type":"cell","id":"9d7b71","pos":99,"input":"params_opt, pcov = curve_fit(fun_modelo,tiempo,fluorescencia,p0 = params_ini)\nprint params_opt","cell_type":"code","exec_count":0}
{"type":"cell","id":"a2d7ad","pos":85,"input":"y_modelo = pendiente*x + ordenada_origen\n\nplot(x,y,'o',x,y_modelo,'r')\nlegend(('Datos','Modelo'),loc=0)","cell_type":"code","exec_count":0}
{"type":"cell","id":"a32cc1","pos":13,"input":"fila1 = y[0,:]\nfila2 = y[1,:]","cell_type":"code","exec_count":0}
{"type":"cell","id":"a38415","pos":67,"input":"x,y = mgrid[-10:10:100j,-10:10:100j] # esta instrucción genera las coordenadas (X,Y) del plano\nz = exp(-((x/2.0)**2 + (y/2.0)**2))\npcolormesh(x,y,z)","cell_type":"code","exec_count":0}
{"type":"cell","id":"a60420","pos":51,"input":"Nota: Hay que decir que además de la forma explicada para cambiar la línea dibujada, se utiliza mucho una forma compacta para escribir menos. La anterior figura se podría generar con, \n\n`plot(tiempo,posicion,'r--',lw=2)`","cell_type":"markdown"}
{"type":"cell","id":"a65548","pos":52,"input":"# Cambio de la región representada","cell_type":"markdown"}
{"type":"cell","id":"a86bf3","pos":65,"input":"# Mapas de color","cell_type":"markdown"}
{"type":"cell","id":"a984c8","pos":0,"input":"Introduce name and family name by clicking twice on this cell.\n\n**Name and family name**:","cell_type":"markdown"}
{"type":"cell","id":"aa4dcd","pos":34,"input":"Lo que nos salvará el resultado de la suma de las dos columnas calculado anteriormente. Si ahora acudimos a la lista de ficheros de nuestro proyecto (arriba a la izquierda en la página de SageMath hay un enlace para verlos), podremos ver el nuevo fichero creado.","cell_type":"markdown"}
{"type":"cell","id":"b04758","pos":14,"input":"Be aware that rows are selected by the first index of the array while columns are referred by the second one.\n\nIn order to visualize any of those data, we use the command `print`","cell_type":"markdown"}
{"type":"cell","id":"b211e0","pos":10,"input":"The first number indicates ua the number of rows (in this case 1000) and the second one gives us the number of columns (2).\n\nNow let's try to select every one of the two columns,","cell_type":"markdown"}
{"type":"cell","id":"b41537","pos":20,"input":"These examples show how to select a variety of particular collection of data inside an array in Python.","cell_type":"markdown"}
{"type":"cell","id":"b5653d","pos":7,"input":"So, first we have to upload the library Numpy and then we can directly call the function `loadtxt`. Thus, we uploaded in the variable `y` the data of the file `data_file.dat`. \n\nThis variable is an *array*, namely, a collection of data, to which we will refer with the name `y`. ","cell_type":"markdown"}
{"type":"cell","id":"b5bce0","pos":94,"input":"Esta caída sabemos por nuestro modelo teórico que debería seguir una suma de dos exponenciales. Es decir, la función a la que debería ajustarse es, \n\n$$f(t) = c_1 e^{-t/t_1} + c_2 e^{-t/t_2}$$\n\nAquí los parámetros del modelo serán $c_1$, $c_2$, $t_1$ y $t_2$. Escritos en una lista serán $[c_1,t_1,c_2,t_2]$. Vamos a definir por tanto nuestra función modelo según esta expresión,","cell_type":"markdown"}
{"type":"cell","id":"b5d573","pos":29,"input":"# Media, desviación estándar de datos","cell_type":"markdown"}
{"type":"cell","id":"ba12eb","pos":98,"input":"Ya solo nos falta llamar a la función `curve_fit` para que realice el ajuste","cell_type":"markdown"}
{"type":"cell","id":"bb6f23","pos":22,"input":"* Selecciona de la variable `y` únicamente entre la fila 10 y la fila 35 de la segunda columna.","cell_type":"markdown"}
{"type":"cell","id":"c17fd8","pos":77,"input":"from scipy.stats import linregress","cell_type":"code","exec_count":0}
{"type":"cell","id":"c3971d","pos":24,"input":"Evidentemente no sólo podemos seleccionar subconjuntos de los datos cargados. Veamos cómo hacer operaciones con ellos y extraer algunas características,","cell_type":"markdown"}
{"type":"cell","id":"c435ca","pos":5,"input":"----------------\n\nIn Python in order to upload a data file we use the function `loadtxt` that is included in the library Numpy. ","cell_type":"markdown"}
{"type":"cell","id":"c4537a","pos":108,"input":"Carga los datos del fichero `ejerc_curvefit.dat`. Separa los datos de cada una de las dos columnas del fichero en dos variables `x` e `y`. Estos datos se deberían ajustar al siguiente modelo, \n\n$$y = a e^{-\\left(\\frac{x -b}{2 c^2}\\right)^2} + d$$\n\n(Nota: esta es la función modelo a usar). \n\n1. Representar estos datos en una figura.\n\n2. Escribir la función modelo, tomando como parámetros: a,b,c,d\n\n3. Escribir una sugerencia inicial para dichos parámetros.\n\n4. Llamar a la función `curve_fit` para realizar un ajuste de los datos cargados al modelo generado.\n\n5. Representar en una figura los datos junto al resultado del modelo, y mostrar los valores de los parámetros óptimos junto a su error.","cell_type":"markdown"}
{"type":"cell","id":"c74ea2","pos":37,"input":"# Figuras","cell_type":"markdown"}
{"type":"cell","id":"cc0a99","pos":95,"input":"def fun_modelo(t,c1,t1,c2,t2): #c1,t1,c2,t2 son los parámetros de nuestro modelo.\n    return c1*exp(-t/t1) + c2*exp(-t/t2)","cell_type":"code","exec_count":0}
{"type":"cell","id":"cd35be","pos":104,"input":"Como vemos se ajusta perfectamente. Pero, ¿y si queremos saber los errores asociados a nuestros parámetros?. Esta información nos la da `pcov`, que también es devuelta por `curve_fit` y no hemos usado hasta ahora. El error de nuestros parámetros viene dado por la raíz cuadrada de los elementos de la diagonal de esta matriz.","cell_type":"markdown"}
{"type":"cell","id":"d4ccd1","pos":31,"input":"# Salvar datos a un fichero","cell_type":"markdown"}
{"type":"cell","id":"d5bea4","pos":21,"input":"# Ejercicio 1","cell_type":"markdown"}
{"type":"cell","id":"d6a93c","pos":66,"input":"Normalmente dibujar unos datos frente a otros no va a ser suficiente a la hora de presentar nuestros resultados. Algunas veces nos encontramos con funciones que dependen de dos variables y que por tanto si las representamos obtendríamos una superficie. \n\nUna forma muy útil de representar este tipo de funciones o datos es mediante los mapas de color, donde a cada valor de la función se le asocia un color. Quizás el ejemplo más cercano pueda ser un mapa de relieve de una zona. En este caso, cada color sería una altura diferente. Combinar este tipo de representación con líneas que marquen las zonas de igual altura también es algo usual y favorece la representación.\n\nEn el presente curso, usaremos los mapas de color ampliamente para visualizar las aberraciones en el plano de la pupila de salida del sistema óptico. Al ser un plano, cada punto vendrá determinado por dos variables $(x,y)$, para el cual tendremos un valor de la aberración $W(x,y)$. Este tema será cubierto al final del curso.\n\n\n\nEn Python, usaremos la función `pcolormesh` para generar mapas de color","cell_type":"markdown"}
{"type":"cell","id":"dc3ed5","pos":30,"input":"mediacol1 = mean(columna1) # o bien mean(y[:,0])\n\ndesvestad_col1 = std(columna1)#std=sqrt(sum_i[(xi-xmedio)^2/N])\n\nprint mediacol1\n\nprint desvestad_col1","cell_type":"code","exec_count":0}
{"type":"cell","id":"dd9d6c","pos":103,"input":"figure(figsize=(7,4))\nplot(tiempo,fluorescencia,'o',tiempo,fun_modelo(tiempo,c1_opt,t1_opt,c2_opt,t2_opt),'r')\nxlabel('Tiempo (ps)',fontsize=14) # el parámetro fontsize permite modificar el tamaño de la letra utilizada\nylabel('Fluorescencia ',fontsize=14)","cell_type":"code","exec_count":0}
{"type":"cell","id":"e185e0","pos":80,"input":"Vamos a dibujar nuestros datos antes de realizar el ajuste lineal.","cell_type":"markdown"}
{"type":"cell","id":"e43354","pos":60,"input":"# Subfiguras","cell_type":"markdown"}
{"type":"cell","id":"e4a1a3","pos":71,"input":"# Ejercicio 3","cell_type":"markdown"}
{"type":"cell","id":"edc219","pos":100,"input":"Como vemos, `curve_fit` nos da los parámetros óptimos, ordenados según se los hemos dado y requiere la función modelo. Así,","cell_type":"markdown"}
{"type":"cell","id":"f24aa4","pos":1,"input":"**Introduction**\n\nIn order to start working, we must upload the proper scientific python libraries. These libraries can be uploaded one by one or, for simplicity, in a collective way by the command `%pylab inline`.","cell_type":"markdown"}
{"type":"cell","id":"f2d69c","pos":106,"input":"c1_opt_error = sqrt(pcov[0,0])\nt1_opt_error = sqrt(pcov[1,1])\nc2_opt_error =sqrt(pcov[2,2])\nt2_opt_error = sqrt(pcov[3,3])\n\nprint \"Parámetros con su error\"\nprint \"c1 = \", c1_opt , 'Error c1 = ', c1_opt_error\nprint \"t1 = \", t1_opt , 'ps', 'Error t1 = ', t1_opt_error, 'ps'\nprint \"c2 = \", c2_opt , 'Error c2 = ', c2_opt_error\nprint \"t2 = \", t2_opt , 'ps', 'Error t2 = ', t2_opt_error, 'ps'","cell_type":"code","exec_count":0}
{"type":"cell","id":"f2df3b","pos":15,"input":"print fila1","cell_type":"code","exec_count":0}
{"type":"cell","id":"f36f92","pos":93,"input":"y = loadtxt('TumorMalignoCaida.dat') \ntiempo = y[:,0]\nfluorescencia = y[:,1]\nplot(tiempo,fluorescencia,'o')","cell_type":"code","exec_count":0}
{"type":"cell","id":"f7f4dd","pos":107,"input":"# Ejercicio 5","cell_type":"markdown"}
{"type":"file","last_load":1528235658920}
{"type":"settings","kernel":"python3","backend_state":"running","metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.5.2"},"name":"","signature":"sha256:edfff3743849da154c975b679f7b6f35444eed79396b899d5f05803ca1292bca"},"trust":true,"kernel_state":"idle","kernel_usage":{"cpu":0,"memory":78331904}}