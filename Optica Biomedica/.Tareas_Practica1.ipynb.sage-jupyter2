{"type":"cell","id":"0344ad","pos":40,"input":"y = loadtxt('prueba_carga_fichero.dat')\ntiempo = y[:,0] # primera columna\nposicion = y[:,1] #segunda columna","cell_type":"code","exec_count":0}
{"type":"cell","id":"036a41","pos":100,"input":"Como vemos, `curve_fit` nos da los parámetros óptimos, ordenados según se los hemos dado y requiere la función modelo. Así,","cell_type":"markdown"}
{"type":"cell","id":"03c31a","pos":84,"input":"Ahora vamos a dibujar superpuestos nuestro modelo y nuestros datos experimentales","cell_type":"markdown"}
{"type":"cell","id":"059cb6","pos":43,"input":"Vemos que ha salido una función sinusoidal. \n\nAhora vamos a describir algunas formas de modificar o enriquecer esta figura.","cell_type":"markdown"}
{"type":"cell","id":"105d7f","pos":12,"input":"Nota para usuarios de Octave: En Octave/MATLAB se usan paréntesis en vez de corchetes. Además, la primera columna sería etiquetada con el índice 1 en vez de 0.\n\n----------\n\nVeamos ahora cómo seleccionar cada una de las filas,","cell_type":"markdown"}
{"type":"cell","id":"10bbab","pos":48,"input":"Hay varias opciones para cambiar las líneas mostradas. Algunas de ellas son:\n\n* Cambio de anchura: Se añade a plot(tiempo,posición) `linewidth = número` donde número por defecto es 1, así que para aumentar el grosor de la línea habrá que indicar un número mayor (por ejemplo, 2)\n\n* Cambio de color: Se añade `color = nombre del cólor en inglés` por ejemplo 'orange', 'red', 'green', etc.\n\n* Cambio de formato: Si queremos que en vez de una línea contínua sea una línea discontínua añadiremos `linestyle='dashed'`, etc.","cell_type":"markdown"}
{"type":"cell","id":"10cb1a","pos":38,"input":"La presentación de los resultados es una tarea esencial en cualquier trabajo, ya sea de laboratorio o de otro tipo. En esta sección vamos a ver cómo podemos hacer figuras en Python. La sintaxis es completamente similar a la utilizada en otros programas como Octave/MATLAB por lo que el paso a estos programas será muy sencillo si se aprende cómo hacerlo en Python.\n\n-----------\n\nEn esta parte asumiremos que ya tenemos un array o varios que queremos dibujar en una figura.","cell_type":"markdown"}
{"type":"cell","id":"10e18b","pos":106,"input":"c1_opt_error = sqrt(pcov[0,0])\nt1_opt_error = sqrt(pcov[1,1])\nc2_opt_error =sqrt(pcov[2,2])\nt2_opt_error = sqrt(pcov[3,3])\n\nprint \"Parámetros con su error\"\nprint \"c1 = \", c1_opt , 'Error c1 = ', c1_opt_error\nprint \"t1 = \", t1_opt , 'ps', 'Error t1 = ', t1_opt_error, 'ps'\nprint \"c2 = \", c2_opt , 'Error c2 = ', c2_opt_error\nprint \"t2 = \", t2_opt , 'ps', 'Error t2 = ', t2_opt_error, 'ps'","cell_type":"code","exec_count":0}
{"type":"cell","id":"120b50","pos":23,"input":"# Otras operaciones con arrays","cell_type":"markdown"}
{"type":"cell","id":"125d6a","pos":101,"input":"c1_opt = params_opt[0]\nt1_opt = params_opt[1]\nc2_opt = params_opt[2]\nt2_opt = params_opt[3]","cell_type":"code","exec_count":0}
{"type":"cell","id":"133e9e","pos":0,"input":"Editar esta celda (haciendo doble click con el ratón) para introducir el nombre y apellidos.\n\n**Nombre y Apellidos**:","cell_type":"markdown"}
{"type":"cell","id":"148b13","pos":70,"input":"particulas = imread('nanopart1.jpg')\nimshow(particulas)","cell_type":"code","exec_count":0}
{"type":"cell","id":"14e290","pos":47,"input":"# Cambio de las propiedades de la línea dibujada","cell_type":"markdown"}
{"type":"cell","id":"1926d9","pos":66,"input":"Normalmente dibujar unos datos frente a otros no va a ser suficiente a la hora de presentar nuestros resultados. Algunas veces nos encontramos con funciones que dependen de dos variables y que por tanto si las representamos obtendríamos una superficie. \n\nUna forma muy útil de representar este tipo de funciones o datos es mediante los mapas de color, donde a cada valor de la función se le asocia un color. Quizás el ejemplo más cercano pueda ser un mapa de relieve de una zona. En este caso, cada color sería una altura diferente. Combinar este tipo de representación con líneas que marquen las zonas de igual altura también es algo usual y favorece la representación.\n\nEn el presente curso, usaremos los mapas de color ampliamente para visualizar las aberraciones en el plano de la pupila de salida del sistema óptico. Al ser un plano, cada punto vendrá determinado por dos variables $(x,y)$, para el cual tendremos un valor de la aberración $W(x,y)$. Este tema será cubierto al final del curso.\n\n\n\nEn Python, usaremos la función `pcolormesh` para generar mapas de color","cell_type":"markdown"}
{"type":"cell","id":"1cd704","pos":20,"input":"Estos ejemplos deberían servir para ver el funcionamiento de la selección de diversos elementos de un array en Python.","cell_type":"markdown"}
{"type":"cell","id":"1e0a07","pos":17,"input":"filas20 = y[0:20,:]\nprint filas20","cell_type":"code","exec_count":0}
{"type":"cell","id":"25c493","pos":36,"input":"* Carga el fichero problema `'problema_datos.dat'` y realiza las siguientes operaciones\n\n    - Calcula la media y la desviación estandar de los datos almacenados en la segunda columna\n    \n    - Suma los elementos de cada columna.\n    \n    - Salva en un fichero el resultado de elevar al cubo la segunda columna.","cell_type":"markdown"}
{"type":"cell","id":"268ad3","pos":57,"input":"Para ello se añaden dentro de plot los distintos pares de vectores $x$ e $y$ a representar, o bien se escribe otra sentencia con plot en la misma celda. Por ejemplo, calculemos la posición al cuadrado y representémosla junto a la posición.","cell_type":"markdown"}
{"type":"cell","id":"276b47","pos":91,"input":"from scipy.optimize import curve_fit\nhelp(curve_fit)","cell_type":"code","exec_count":0}
{"type":"cell","id":"296a2b","pos":16,"input":"Nos devuelve un array de dos elementos (porque hay dos columnas)\n\n\n¿Y si queremos seleccionar solo las primeras 20 filas?","cell_type":"markdown"}
{"type":"cell","id":"2d5e65","pos":25,"input":"# Suma, resta, multiplicación, etc","cell_type":"markdown"}
{"type":"cell","id":"2f8e4c","pos":11,"input":"columna1 = y[:,0]\ncolumna2 = y[:,1]","cell_type":"code","exec_count":0}
{"type":"cell","id":"34daf7","pos":95,"input":"def fun_modelo(t,c1,t1,c2,t2): #c1,t1,c2,t2 son los parámetros de nuestro modelo.\n    return c1*exp(-t/t1) + c2*exp(-t/t2)","cell_type":"code","exec_count":0}
{"type":"cell","id":"37719d","pos":74,"input":"**Introducción previa**\n\nPara hacer un ajuste a unos datos vamos a usar el módulo Scipy. Hay múltiples posibilidades en Scipy a la hora de abordar el ajuste de un conjunto de datos a un cierto modelo, sea este lineal (una recta), polinómico o una función arbitraria. Nos centraremos en cómo hacer una regresión lineal básica con Scipy y en cómo hacer un ajuste a un modelo arbitrario. En ambos casos, lo que subyace en los algoritmos utilizados es minimizar la suma de las distancias de nuestra curva ajuste a nuestros datos en cada punto. Es decir, un ajuste por mínimos cuadrados.","cell_type":"markdown"}
{"type":"cell","id":"38674c","pos":42,"input":"plot(tiempo,posicion)","cell_type":"code","exec_count":0}
{"type":"cell","id":"38c11c","pos":55,"input":"# Otro ejemplo\nplot(tiempo,posicion,color='red',linewidth=2,linestyle='dashed')\nxlim(40,60)\nylim(-5,5)","cell_type":"code","exec_count":0}
{"type":"cell","id":"390ce4","pos":49,"input":"plot(tiempo,posicion,color='orange')","cell_type":"code","exec_count":0}
{"type":"cell","id":"44d9f5","pos":34,"input":"Lo que nos salvará el resultado de la suma de las dos columnas calculado anteriormente. Si ahora acudimos a la lista de ficheros de nuestro proyecto (arriba a la izquierda en la página de SageMath hay un enlace para verlos), podremos ver el nuevo fichero creado.","cell_type":"markdown"}
{"type":"cell","id":"45e940","pos":86,"input":"Uno de los problemas que podemos tener al usar la función `linregress` es obtener el error en la pendiente y la ordenada en el origen. Estos errores no son devueltos por esta función, por lo que deberíamos calcularlos a mano. Sin embargo, también podemos usar otras funciones más completas en Python para obtenerlos. Una de ellas es la función `curve_fit` la cual veremos a continuación.","cell_type":"markdown"}
{"type":"cell","id":"4c871e","pos":22,"input":"* Selecciona de la variable `y` únicamente entre la fila 10 y la fila 35 de la segunda columna.","cell_type":"markdown"}
{"type":"cell","id":"4d8e52","pos":62,"input":"subplot(1,2,1) # subplot(numero filas, numero columnas, figura en la que dibujaremos)\nplot(tiempo,posicion, color='red', linewidth=2)\n\nsubplot(1,2,2) # ahora cambiando el último argumento elegimos la segunda figura para dibujar\nplot(tiempo,posicion-std(posicion), color='black', linewidth=2) # podemos hacer operaciones dentro de plot","cell_type":"code","exec_count":0}
{"type":"cell","id":"4daa16","pos":67,"input":"x,y = mgrid[-10:10:100j,-10:10:100j] # esta instrucción genera las coordenadas (X,Y) del plano\nz = exp(-((x/2.0)**2 + (y/2.0)**2))\npcolormesh(x,y,z)","cell_type":"code","exec_count":0}
{"type":"cell","id":"50cc49","pos":105,"input":"print pcov # Mostramos la matriz pcov","cell_type":"code","exec_count":0}
{"type":"cell","id":"522efe","pos":64,"input":"figure(figsize=(15,4))\nsubplot(1,2,1) # subplot(numero filas, numero columnas, figura en la que dibujaremos)\nplot(tiempo,posicion, color='red', linewidth=2)\n\nsubplot(1,2,2) # ahora cambiando el último argumento elegimos la segunda figura para dibujar\nplot(tiempo,posicion-std(posicion), color='black', linewidth=2) # podemos hacer operaciones dentro de plot","cell_type":"code","exec_count":0}
{"type":"cell","id":"56b61d","pos":75,"input":"# Regresión lineal","cell_type":"markdown"}
{"type":"cell","id":"5861f0","pos":103,"input":"figure(figsize=(7,4))\nplot(tiempo,fluorescencia,'o',tiempo,fun_modelo(tiempo,c1_opt,t1_opt,c2_opt,t2_opt),'r')\nxlabel('Tiempo (ps)',fontsize=14) # el parámetro fontsize permite modificar el tamaño de la letra utilizada\nylabel('Fluorescencia ',fontsize=14)","cell_type":"code","exec_count":0}
{"type":"cell","id":"587956","pos":44,"input":"# Adición de etiquetas en los ejes","cell_type":"markdown"}
{"type":"cell","id":"5b83b4","pos":15,"input":"print fila1","cell_type":"code","exec_count":0}
{"type":"cell","id":"60064c","pos":10,"input":"El primer número nos indica el número de filas (en este caso 1000), y el segundo nos indica el número de columnas (2).\n\nVeamos cómo seleccionar cada una de las columnas,","cell_type":"markdown"}
{"type":"cell","id":"637f77","pos":82,"input":"Ahora realizamos el ajuste siguiendo la ayuda de la función `linregress` que nos indica cómo introducir los datos","cell_type":"markdown"}
{"type":"cell","id":"64e802","pos":39,"input":"--------\n\nSupongamos entonces que tenemos dos arrays, `tiempo` y `posicion` por ejemplo, que pueden provenir de cargar un fichero de datos, quizás del fichero utilizado anteriormente `prueba_carga_fichero.dat`.","cell_type":"markdown"}
{"type":"cell","id":"6769f2","pos":27,"input":"multiplicacion = columna1*columna2\n\ndivision = columna1/columna2\n\npotencia = columna1**2\n\nsuma_col = columna1 + columna2","cell_type":"code","exec_count":0}
{"type":"cell","id":"6950d6","pos":92,"input":"Esta función es un poco más compleja que `linregress`, pero es el precio que pagamos por tener una herramienta más flexible. Vamos a describir los distintos argumentos de la función y cómo se emplea.\n\n\n* Argumentos\n\n    * `f` la cual es la función modelo a la que queremos ajustar nuestras medidas. La función `curve_fit` asume que nuestros datos (`x_data`, `ydata`) siguen esta función, es decir, `ydata = f(x_data, *params) + eps`. Aquí `eps` es un cierto error que el programa intentará minimizar, mientras que `*params` son los parámetros de nuestra función (es decir, otros argumentos de la función que no son nuestras medidas experimentales). \n    \n    Por ejemplo, si nuestros datos siguen una función gaussiana, $f(x) = a e^{-b(x-x_0)^2}$, los parámetros que variaremos para encontrar aquella que se ajuste a nuestros datos serán $a$ y $b$.\n    \n    * `xdata`,`ydata` son nuestros datos, los que queremos ajustar.\n    \n    * `p0` son los parámetros iniciales a partir de los cuales `curve_fit` intenta ajustar la función. Este argumento se puede no dar, en cuyo caso `curve_fit` comienza con los parámetros igual a 1. En nuestro ejemplo de la función gaussiana, los parámetros son [$a$,$b$] (escritos como una lista). Si sabemos que, por ejemplo, el valor de $a$ se encuentra próximo a 0.6 y $b$ próximo a 5.8, daríamos como sugerencia al programa `p0 = [0.6,5.8]`. **Dar una sugerencia inicial correcta al programa de ajuste permite que el ajuste se realice más rápidamente. Incluso podría ser que sin ella la función `curve_fit` no sea capaz de encontrar los parámetros adecuados**.\n    \n    * `sigma` es un vector que nos da el error de cada una de las medidas de `ydata`. Si no se especifica, se considera que los errores son nulos.\n     \n* Salida de `curve_fit`\n    \n    * `popt` Como salida de la función `curve_fit` obtenemos primero una lista de los parámetros óptimos que se han encontrado. En nuestro caso, si nuestros parámetros son [$a$,$b$], obtendríamos los parámetros óptimos del ajuste [$a_{opt}$, $b_{opt}$].\n    \n    * `pcov` es la matriz de covarianza de los parámetros. La raíz cuadrada de su diagonal nos proporciona el error (desviación estándar) de cada uno de los parámetros.\n    \n    \nVeamos un ejemplo de su uso. Vamos a intentar ajustar la caída de la señal de fluorescencia medida en una muestra de tejido con un tumor maligno a un modelo con una doble exponencial (este modelo se verá en las clases de teoría).","cell_type":"markdown"}
{"type":"cell","id":"6beb0b","pos":41,"input":"Ahora queremos visualizar `posicion` frente a `tiempo`. Utilizaremos la función `plot` del módulo Matplotlib, que hemos cargado anteriormente.","cell_type":"markdown"}
{"type":"cell","id":"6e5098","pos":35,"input":"# Ejercicio 2","cell_type":"markdown"}
{"type":"cell","id":"7300cc","pos":58,"input":"pos2 = posicion**2\nplot(tiempo,posicion,tiempo,pos2)","cell_type":"code","exec_count":0}
{"type":"cell","id":"730cdb","pos":50,"input":"plot(tiempo,posicion,color='red',linewidth=2,linestyle='dashed')","cell_type":"code","exec_count":0}
{"type":"cell","id":"7332b2","pos":51,"input":"Nota: Hay que decir que además de la forma explicada para cambiar la línea dibujada, se utiliza mucho una forma compacta para escribir menos. La anterior figura se podría generar con, \n\n`plot(tiempo,posicion,'r--',lw=2)`","cell_type":"markdown"}
{"type":"cell","id":"7540f0","pos":9,"input":"shape(y)","cell_type":"code","exec_count":0}
{"type":"cell","id":"76390e","pos":87,"input":"# Ejercicio 4","cell_type":"markdown"}
{"type":"cell","id":"7838f3","pos":61,"input":"Para hacer varias subfiguras podemos utilizar el comando `subplot` varias veces de la siguiente forma.","cell_type":"markdown"}
{"type":"cell","id":"7a07b4","pos":85,"input":"y_modelo = pendiente*x + ordenada_origen\n\nplot(x,y,'o',x,y_modelo,'r')\nlegend(('Datos','Modelo'),loc=0)","cell_type":"code","exec_count":0}
{"type":"cell","id":"7d9b64","pos":32,"input":"Cuando hemos terminado de procesar los datos, frecuentemente querremos salvar los resultados en un fichero. Esta operación se realiza en Python con la función `savetxt`. Su funcionamiento es el siguiente:\n\n`savetxt('nombredelfichero', variable)`\n\nEs decir, primero damos el nombre del fichero entre comillas simples (o dobles, da igual) y a continuación, como segundo argumento, el nombre de la variable que queremos salvar. Veamos un ejemplo,","cell_type":"markdown"}
{"type":"cell","id":"7dcce4","pos":4,"input":"Cuando trabajamos en el laboratorio, y queramos analizar las medidas, vamos a necesitar contínuamente cargar los datos obtenidos y realizar operaciones con ellos, como son ajustes a un modelo teórico, además de representar los resultados para poder mostrarlos.\n\nEn este apartado de la práctica vamos a aprender cómo hacer este proceso. Supondremos que hemos realizado una cierta medida con un aparato que nos ha devuelto un fichero de datos, normalmente de varias columnas. Veremos cómo cargar esos datos a nuestro programa de Python y realizar algunas operaciones con ellos. Posteriormente, en la siguiente sección, veremos cómo hacer figuras para mostrar los resultados.","cell_type":"markdown"}
{"type":"cell","id":"8347d5","pos":18,"input":"¿Y si queremos seleccionar las primeras 15 filas de la primera columna?","cell_type":"markdown"}
{"type":"cell","id":"83aa75","pos":93,"input":"y = loadtxt('TumorMalignoCaida.dat') \ntiempo = y[:,0]\nfluorescencia = y[:,1]\nplot(tiempo,fluorescencia,'o')","cell_type":"code","exec_count":0}
{"type":"cell","id":"83c362","pos":19,"input":"filas15col1 = y[0:15,0]\nprint filas15col1","cell_type":"code","exec_count":0}
{"type":"cell","id":"8a171c","pos":5,"input":"----------------\n\nEn Python (aunque la sintaxis es muy similar en otros programas), para cargar un fichero de datos usaremos la función `loadtxt` que se encuentra dentro del módulo Numpy. Su funcionamiento es muy simple","cell_type":"markdown"}
{"type":"cell","id":"8b857c","pos":88,"input":"Carga los datos (2 columnas) del fichero `ejerc_reglin.dat` en una variable, y realiza un ajuste lineal a dichos datos. Muestra el valor de la pendiente y de la ordenada en el origen y justifica si consideras que el ajuste da la tendencia de los datos.","cell_type":"markdown"}
{"type":"cell","id":"8cacb1","pos":99,"input":"params_opt, pcov = curve_fit(fun_modelo,tiempo,fluorescencia,p0 = params_ini)\nprint params_opt","cell_type":"code","exec_count":0}
{"type":"cell","id":"8e59e5","pos":90,"input":"Aunque en ocasiones podemos ajustar nuestras medidas para obtener información de un ajuste lineal, en la mayoría de los casos nuestro modelo será algo distinto a una recta. ¿Podemos obtener los parámetros de un modelo con una dependencia arbitraria mediante un ajuste a nuestras medidas experimentales?. La respuesta es, por supuesto, sí, y como se ha comentado anteriormente, Python proporciona múltiples funciones para hacer este tipo de análisis. \n\nNosotros vamos a centrarnos en la función `curve_fit`, la cual es parte del submódulo `optimize` de Scipy. Vamos a importarla y ver su funcionamiento con el comando help.","cell_type":"markdown"}
{"type":"cell","id":"906276","pos":29,"input":"# Media, desviación estándar de datos","cell_type":"markdown"}
{"type":"cell","id":"922c3d","pos":102,"input":"Vamos a ver ahora el resultado de nuestro ajuste, dibujando en una gráfica los puntos experimentales y nuestro modelo.","cell_type":"markdown"}
{"type":"cell","id":"945e9d","pos":53,"input":"¿Qué ocurre si no queremos representar todo el rango que recorren los datos?. Por ejemplo, ¿cómo hacemos para representar únicamente la región de tiempos entre 40 s y 60 s en el ejemplo anterior?. \n\nPara ello debemos modificar el rango de representación de los ejes. Se hace de la siguiente forma,","cell_type":"markdown"}
{"type":"cell","id":"9554ee","pos":68,"input":"# Trabajo con imágenes","cell_type":"markdown"}
{"type":"cell","id":"96a47d","pos":96,"input":"Ahora vamos a dar una sugerencia inicial a nuestros parámetros para que a `curve_fit` le sea más sencillo ajustar los datos experimentales","cell_type":"markdown"}
{"type":"cell","id":"976f83","pos":14,"input":"Vemos que las filas se seleccionan con el primer índice, mientras que las columnas se seleccionan con el segundo.\n\nSi queremos visualizar alguna de las filas o columnas, lo podemos hacer con el comando `print`","cell_type":"markdown"}
{"type":"cell","id":"9af9be","pos":56,"input":"# Dibujar varias líneas a la vez en una misma figura","cell_type":"markdown"}
{"type":"cell","id":"9b57bc","pos":6,"input":"y = loadtxt('prueba_carga_fichero.dat')","cell_type":"code","exec_count":0}
{"type":"cell","id":"9b6899","pos":69,"input":"Cuando trabajamos con cámaras CCD necesitaremos cargar en el programa una imagen ya capturada para realizar un análisis de ella, por ejemplo para realizar filtros, ver el tamaño de las estructuras observadas, etc.\n\nPara cargar imágenes se utiliza una función distinta a la de carga de ficheros de datos. Esta función se llama `imread`. Con esta función cargaremos la imagen en una variable, que será un array bidimensional (una matriz). Posteriormente, para visualizar la imagen debemos utilizar la función `imshow`. Veamos cómo funcionan con un ejemplo,","cell_type":"markdown"}
{"type":"cell","id":"9c5477","pos":79,"input":"prueba = loadtxt('prueba_reglin.dat')\nx = prueba[:,0]\ny = prueba[:,1]","cell_type":"code","exec_count":0}
{"type":"cell","id":"9ccf4c","pos":46,"input":"plot(tiempo,posicion)\nxlabel('Tiempo (s)')\nylabel('Posicion (cm)')","cell_type":"code","exec_count":0}
{"type":"cell","id":"9daf0e","pos":94,"input":"Esta caída sabemos por nuestro modelo teórico que debería seguir una suma de dos exponenciales. Es decir, la función a la que debería ajustarse es, \n\n$$f(t) = c_1 e^{-t/t_1} + c_2 e^{-t/t_2}$$\n\nAquí los parámetros del modelo serán $c_1$, $c_2$, $t_1$ y $t_2$. Escritos en una lista serán $[c_1,t_1,c_2,t_2]$. Vamos a definir por tanto nuestra función modelo según esta expresión,","cell_type":"markdown"}
{"type":"cell","id":"9e8fa8","pos":65,"input":"# Mapas de color","cell_type":"markdown"}
{"type":"cell","id":"a20ddb","pos":1,"input":"**Introducción**\n\nPara comenzar a trabajar, debemos cargar los módulos de cálculo científico que dan a Python la funcionalidad que queremos. Como se ha comentado en el trabajo previo, importar estos módulos puede hacerse de manera individual, o bien de manera conjunta con el comando `%pylab inline`. Para facilitar la puesta en marcha, utilizaremos esta última forma","cell_type":"markdown"}
{"type":"cell","id":"a39b02","pos":108,"input":"Carga los datos del fichero `ejerc_curvefit.dat`. Separa los datos de cada una de las dos columnas del fichero en dos variables `x` e `y`. Estos datos se deberían ajustar al siguiente modelo, \n\n$$y = a e^{-\\left(\\frac{x -b}{2 c^2}\\right)^2} + d$$\n\n(Nota: esta es la función modelo a usar). \n\n1. Representar estos datos en una figura.\n\n2. Escribir la función modelo, tomando como parámetros: a,b,c,d\n\n3. Escribir una sugerencia inicial para dichos parámetros.\n\n4. Llamar a la función `curve_fit` para realizar un ajuste de los datos cargados al modelo generado.\n\n5. Representar en una figura los datos junto al resultado del modelo, y mostrar los valores de los parámetros óptimos junto a su error.","cell_type":"markdown"}
{"type":"cell","id":"a6f9a7","pos":26,"input":"La suma, resta, multiplicación, división, elevar a una potencia, o aplicar una función a un array, se realizan como si fueran números. Por defecto Python realiza la operación elemento a elemento.","cell_type":"markdown"}
{"type":"cell","id":"a86d2c","pos":8,"input":"----------\nYa está, hemos cargado los datos de nuestro fichero en el programa. Vamos a ver ahora cómo seleccionamos algunos datos (columnas, filas), y algunas operaciones que podemos hacer con ellos.\n\n**¿Cuántas filas y columnas tiene la variable `y`?**\n\nEsta información la podemos obtener con la función `shape`, ","cell_type":"markdown"}
{"type":"cell","id":"ac9d09","pos":72,"input":"* Carga el fichero 'problema_figuras.dat' . Este fichero tiene 3 columnas. La primera se corresponde al tiempo, la segunda a la intensidad de la señal de fluorescencia medida para una cierta muestra, y la tercera, la misma fluorescencia pero para otra muestra diferente. Asigna cada columna a una variable distinta\n\n* A continuación, dibuja la segunda columna frente a la primera, utilizando un rango de representación adecuado, de modo que únicamente se vea el decaimiento de la señal desde su máximo. Indica utilizando las etiquetas que el eje X se corresponde con el tiempo y el eje Y se corresponde con la intensidad. \n\n* En una figura nueva, dibuja en dos subfiguras cada una de las señales de fluorescencia con respecto al tiempo. Añade etiquetas, utiliza un color diferente para cada una de las dos curvas y asigna un grosor de línea de 2 a ambas líneas.","cell_type":"markdown"}
{"type":"cell","id":"ae3cec","pos":97,"input":"c1_ini = 20.0\nc2_ini = 20.0\nt1_ini = 100.0\nt2_ini = 500.0\nparams_ini = [c1_ini,t1_ini,c2_ini,t2_ini] # ordenados según los requiere la función modelo.","cell_type":"code","exec_count":0}
{"type":"cell","id":"b1b3b2","pos":98,"input":"Ya solo nos falta llamar a la función `curve_fit` para que realice el ajuste","cell_type":"markdown"}
{"type":"cell","id":"b216bf","pos":81,"input":"plot(x,y,'o')","cell_type":"code","exec_count":0}
{"type":"cell","id":"b2468b","pos":7,"input":"Como vemos, primero hemos cargado todas las funciones del módulo Numpy para poder usarlas. Después, hemos cargado los datos que se encuentran en el fichero `prueba_carga_fichero.dat` en la variable `y`. \n\nEsta variable es un *array*, es decir, un conjunto de datos. A partir de ahora nos referiremos a ella con este nombre. ","cell_type":"markdown"}
{"type":"cell","id":"b627ad","pos":89,"input":"# Ajuste a un modelo arbitrario","cell_type":"markdown"}
{"type":"cell","id":"b98a57","pos":24,"input":"Evidentemente no sólo podemos seleccionar subconjuntos de los datos cargados. Veamos cómo hacer operaciones con ellos y extraer algunas características,","cell_type":"markdown"}
{"type":"cell","id":"b9a59a","pos":78,"input":"La función `linregress` toma como argumentos dos arrays `x` e `y`, que toma como dos conjuntos de medidas que deben tener la misma longitud. Por otro lado, devuelve,\n\n* `slope`, es decir, la pendiente que hemos llamado $m$ anteriormente,\n* `intercept`, que es la ordenada en el origen $b$,\n* `r_value` que es el coeficiente de correlación para estimar la bondad de nuestro ajuste.\n* `p_value` el cual es un parámetro que nos da la probabilidad de que nuestro resultado se pudiera obtener con un modelo distinto. En este caso, que la pendiente sea nula. Si es menor que un 5% aproximadamente, es que nuestra hipótesis inicial es correcta. \n* `stderr` nos da una medida de cuánto se aleja nuestra curva de los puntos experimentales\n\nDe la salida de la función, nos interesará los 3 primeros valores, especialmente.\nVamos a aplicarlo a un ejemplo. Primero cargaremos los datos de un fichero que tiene dos columnas y asignaremos cada columna a una variable `x` e `y`. ","cell_type":"markdown"}
{"type":"cell","id":"ba54b1","pos":54,"input":"plot(tiempo,posicion,color='red',linewidth=2,linestyle='dashed')\nxlim(40,60)","cell_type":"code","exec_count":0}
{"type":"cell","id":"c0a4b0","pos":104,"input":"Como vemos se ajusta perfectamente. Pero, ¿y si queremos saber los errores asociados a nuestros parámetros?. Esta información nos la da `pcov`, que también es devuelta por `curve_fit` y no hemos usado hasta ahora. El error de nuestros parámetros viene dado por la raíz cuadrada de los elementos de la diagonal de esta matriz.","cell_type":"markdown"}
{"type":"cell","id":"c17843","pos":80,"input":"Vamos a dibujar nuestros datos antes de realizar el ajuste lineal.","cell_type":"markdown"}
{"type":"cell","id":"c68165","pos":76,"input":"Supongamos que tenemos un conjunto de pares de datos $(X,Y)$, que sabemos (o sospechamos) que siguen una relación lineal. Es decir, \n\n$$Y = m X + b$$\n\n¿Cómo podemos con Python obtener $m$ y $b$?. Vamos a usar la función `linregress` del submódulo de Scipy dedicado a estadística *Scipy.stats*. Así pues lo primero que debemos hacer es importar esta función. Supondremos que ya tenemos cargados el resto de módulos por haber ejecutado anteriormente el comando `%pylab inline`. Si no es así, incluir este comando en la celda siguiente y ejecutarla.","cell_type":"markdown"}
{"type":"cell","id":"cf5795","pos":52,"input":"# Cambio de la región representada","cell_type":"markdown"}
{"type":"cell","id":"d22f32","pos":71,"input":"# Ejercicio 3","cell_type":"markdown"}
{"type":"cell","id":"d274ff","pos":63,"input":"Si la figura no queda bien de tamaño, podemos modificarla con el comando, \n\n`figure(figsize=(tamañoX, tamañoY))`\n\nLos parámetros de tamaño dependen de la resolución de la pantalla, así que lo mejor es probar con algunos hasta ver la figura de un tamaño adecuado.","cell_type":"markdown"}
{"type":"cell","id":"d2d000","pos":37,"input":"# Figuras","cell_type":"markdown"}
{"type":"cell","id":"d3c9dc","pos":77,"input":"from scipy.stats import linregress","cell_type":"code","exec_count":0}
{"type":"cell","id":"d4ebaf","pos":60,"input":"# Subfiguras","cell_type":"markdown"}
{"type":"cell","id":"d5d83c","pos":28,"input":"nuevoarray = 5*cos(columna1) ","cell_type":"code","exec_count":0}
{"type":"cell","id":"deb0ff","pos":31,"input":"# Salvar datos a un fichero","cell_type":"markdown"}
{"type":"cell","id":"e049fc","pos":59,"input":"plot(tiempo,posicion,color='red',linewidth=2,linestyle='dashed')\nplot(tiempo,pos2,color='blue',linewidth=2)","cell_type":"code","exec_count":0}
{"type":"cell","id":"e167a8","pos":73,"input":"# Ajuste de datos","cell_type":"markdown"}
{"type":"cell","id":"e5b367","pos":107,"input":"# Ejercicio 5","cell_type":"markdown"}
{"type":"cell","id":"e66be2","pos":30,"input":"mediacol1 = mean(columna1) # o bien mean(y[:,0])\n\ndesvestad_col1 = std(columna1)#std=sqrt(sum_i[(xi-xmedio)^2/N])\n\nprint mediacol1\n\nprint desvestad_col1","cell_type":"code","exec_count":0}
{"type":"cell","id":"e714c6","pos":21,"input":"# Ejercicio 1","cell_type":"markdown"}
{"type":"cell","id":"ec81c1","pos":45,"input":"Podemos añadir etiquetas en los ejes mediante los comandos `xlabel` e `ylabel`.","cell_type":"markdown"}
{"type":"cell","id":"f26b1a","pos":2,"input":"%pylab inline","output":{"0":{"name":"stdout","output_type":"stream","stream":"stdout","text":"Populating the interactive namespace from numpy and matplotlib\n"}},"cell_type":"code","exec_count":1}
{"type":"cell","id":"f3c82c","pos":3,"input":"# Trabajo con ficheros de datos","cell_type":"markdown"}
{"type":"cell","id":"f5c1f8","pos":83,"input":"pendiente, ordenada_origen,r,p,stderr = linregress(x,y)\nprint 'pendiente = ', pendiente\nprint 'ordenada en el origen = ' , ordenada_origen\nprint 'coeficiente de correlación r = ', r","cell_type":"code","exec_count":0}
{"type":"cell","id":"f882f8","pos":33,"input":"savetxt('prueba_salvar_datos.dat',suma_col)","cell_type":"code","exec_count":0}
{"type":"cell","id":"fce76b","pos":13,"input":"fila1 = y[0,:]\nfila2 = y[1,:]","cell_type":"code","exec_count":0}
{"type":"file","last_load":1528201544685}
{"type":"settings","metadata":{"name":"","signature":"sha256:edfff3743849da154c975b679f7b6f35444eed79396b899d5f05803ca1292bca","language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.5.2"}},"backend_state":"running","kernel":"python3","trust":false,"kernel_usage":{"cpu":0,"memory":77504512},"kernel_state":"idle"}